
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>chunker: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dan-solli/gognee/pkg/chunker/chunker.go (92.3%)</option>
				
				<option value="file1">github.com/dan-solli/gognee/pkg/embeddings/openai.go (85.4%)</option>
				
				<option value="file2">github.com/dan-solli/gognee/pkg/extraction/entities.go (100.0%)</option>
				
				<option value="file3">github.com/dan-solli/gognee/pkg/extraction/relations.go (100.0%)</option>
				
				<option value="file4">github.com/dan-solli/gognee/pkg/gognee/decay.go (100.0%)</option>
				
				<option value="file5">github.com/dan-solli/gognee/pkg/gognee/gognee.go (83.6%)</option>
				
				<option value="file6">github.com/dan-solli/gognee/pkg/llm/openai.go (90.6%)</option>
				
				<option value="file7">github.com/dan-solli/gognee/pkg/search/decay.go (81.2%)</option>
				
				<option value="file8">github.com/dan-solli/gognee/pkg/search/graph.go (90.7%)</option>
				
				<option value="file9">github.com/dan-solli/gognee/pkg/search/hybrid.go (82.9%)</option>
				
				<option value="file10">github.com/dan-solli/gognee/pkg/search/search.go (75.0%)</option>
				
				<option value="file11">github.com/dan-solli/gognee/pkg/search/vector.go (82.4%)</option>
				
				<option value="file12">github.com/dan-solli/gognee/pkg/store/memory_vector.go (100.0%)</option>
				
				<option value="file13">github.com/dan-solli/gognee/pkg/store/sqlite.go (83.3%)</option>
				
				<option value="file14">github.com/dan-solli/gognee/pkg/store/sqlite_vector.go (87.7%)</option>
				
				<option value="file15">github.com/dan-solli/gognee/pkg/store/vector.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package chunker

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "strings"
        "unicode"
)

// Chunk represents a single chunk of text with metadata
type Chunk struct {
        ID         string
        Text       string
        Index      int
        TokenCount int
}

// Chunker splits text into overlapping chunks with sentence boundary awareness
type Chunker struct {
        MaxTokens int // Maximum tokens per chunk (default: 512)
        Overlap   int // Token overlap between chunks (default: 50)
}

// Chunk splits the input text into chunks
func (c *Chunker) Chunk(text string) []Chunk <span class="cov4" title="7">{
        if text == "" </span><span class="cov1" title="1">{
                return []Chunk{}
        }</span>

        // Apply defaults if not set
        <span class="cov4" title="6">maxTokens := c.MaxTokens
        if maxTokens == 0 </span><span class="cov0" title="0">{
                maxTokens = 512
        }</span>
        <span class="cov4" title="6">overlap := c.Overlap
        if overlap == 0 </span><span class="cov0" title="0">{
                overlap = 50
        }</span>

        // Split text into sentences for boundary awareness
        <span class="cov4" title="6">sentences := splitSentences(text)
        if len(sentences) == 0 </span><span class="cov0" title="0">{
                return []Chunk{}
        }</span>

        <span class="cov4" title="6">var chunks []Chunk
        var currentChunk []string
        var currentTokenCount int

        for _, sentence := range sentences </span><span class="cov4" title="10">{
                sentenceTokens := countTokens(sentence)

                // If adding this sentence would exceed max tokens, finalize current chunk
                if currentTokenCount+sentenceTokens &gt; maxTokens &amp;&amp; len(currentChunk) &gt; 0 </span><span class="cov2" title="2">{
                        chunkText := strings.Join(currentChunk, " ")
                        chunks = append(chunks, Chunk{
                                ID:         generateChunkID(chunkText, len(chunks)),
                                Text:       chunkText,
                                Index:      len(chunks),
                                TokenCount: currentTokenCount,
                        })

                        // Keep overlap tokens for next chunk
                        currentChunk = getOverlapSentences(currentChunk, overlap)
                        currentTokenCount = countTokensForSentences(currentChunk)
                }</span>

                <span class="cov4" title="10">currentChunk = append(currentChunk, sentence)
                currentTokenCount += sentenceTokens</span>
        }

        // Add final chunk if there's remaining content
        <span class="cov4" title="6">if len(currentChunk) &gt; 0 </span><span class="cov4" title="6">{
                chunkText := strings.Join(currentChunk, " ")
                chunks = append(chunks, Chunk{
                        ID:         generateChunkID(chunkText, len(chunks)),
                        Text:       chunkText,
                        Index:      len(chunks),
                        TokenCount: currentTokenCount,
                })
        }</span>

        <span class="cov4" title="6">return chunks</span>
}

// splitSentences splits text into sentences based on common terminators
func splitSentences(text string) []string <span class="cov4" title="6">{
        // Simple sentence splitting on ., !, ? followed by space or end
        var sentences []string
        var current strings.Builder

        runes := []rune(text)
        for i := 0; i &lt; len(runes); i++ </span><span class="cov10" title="206">{
                current.WriteRune(runes[i])

                // Check for sentence terminators
                if runes[i] == '.' || runes[i] == '!' || runes[i] == '?' </span><span class="cov4" title="9">{
                        // Check if followed by space/end
                        if i+1 &gt;= len(runes) || unicode.IsSpace(runes[i+1]) </span><span class="cov4" title="9">{
                                sentence := strings.TrimSpace(current.String())
                                if sentence != "" </span><span class="cov4" title="9">{
                                        sentences = append(sentences, sentence)
                                }</span>
                                <span class="cov4" title="9">current.Reset()</span>
                        }
                }
        }

        // Add any remaining text
        <span class="cov4" title="6">if current.Len() &gt; 0 </span><span class="cov1" title="1">{
                sentence := strings.TrimSpace(current.String())
                if sentence != "" </span><span class="cov1" title="1">{
                        sentences = append(sentences, sentence)
                }</span>
        }

        // Fallback: if no sentences detected, treat whole text as one sentence
        <span class="cov4" title="6">if len(sentences) == 0 &amp;&amp; strings.TrimSpace(text) != "" </span><span class="cov0" title="0">{
                sentences = append(sentences, strings.TrimSpace(text))
        }</span>

        <span class="cov4" title="6">return sentences</span>
}

// countTokens estimates token count using word-based heuristic
// Note: This is an approximation. For accurate token counting, use a proper tokenizer.
func countTokens(text string) int <span class="cov5" title="16">{
        words := strings.Fields(text)
        return len(words)
}</span>

// countTokensForSentences counts total tokens for a slice of sentences
func countTokensForSentences(sentences []string) int <span class="cov2" title="2">{
        total := 0
        for _, s := range sentences </span><span class="cov2" title="2">{
                total += countTokens(s)
        }</span>
        <span class="cov2" title="2">return total</span>
}

// getOverlapSentences returns the last N tokens worth of sentences for overlap
func getOverlapSentences(sentences []string, overlapTokens int) []string <span class="cov2" title="2">{
        if overlapTokens == 0 || len(sentences) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Count backwards from end to get ~overlapTokens
        <span class="cov2" title="2">totalTokens := 0
        startIdx := len(sentences)

        for i := len(sentences) - 1; i &gt;= 0; i-- </span><span class="cov3" title="4">{
                tokens := countTokens(sentences[i])
                if totalTokens+tokens &gt; overlapTokens &amp;&amp; startIdx != len(sentences) </span><span class="cov2" title="2">{
                        break</span>
                }
                <span class="cov2" title="2">totalTokens += tokens
                startIdx = i</span>
        }

        <span class="cov2" title="2">return sentences[startIdx:]</span>
}

// generateChunkID creates a deterministic ID using content hash and index
func generateChunkID(text string, index int) string <span class="cov4" title="8">{
        hash := sha256.Sum256([]byte(text))
        hashStr := hex.EncodeToString(hash[:8]) // Use first 8 bytes for brevity
        return fmt.Sprintf("%s-%d", hashStr, index)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package embeddings

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

const (
        defaultOpenAIURL  = "https://api.openai.com/v1/embeddings"
        defaultModel      = "text-embedding-3-small"
        defaultMaxRetries = 3
)

// OpenAIClient implements EmbeddingClient using OpenAI's API
type OpenAIClient struct {
        APIKey     string
        Model      string
        BaseURL    string
        HTTPClient *http.Client
}

// NewOpenAIClient creates a new OpenAI embedding client
func NewOpenAIClient(apiKey string) *OpenAIClient <span class="cov10" title="7">{
        return &amp;OpenAIClient{
                APIKey:     apiKey,
                Model:      defaultModel,
                BaseURL:    defaultOpenAIURL,
                HTTPClient: http.DefaultClient,
        }
}</span>

type openAIRequest struct {
        Input []string `json:"input"`
        Model string   `json:"model"`
}

type openAIResponse struct {
        Data []struct {
                Embedding []float32 `json:"embedding"`
                Index     int       `json:"index"`
        } `json:"data"`
        Error *openAIError `json:"error,omitempty"`
}

type openAIError struct {
        Message string `json:"message"`
        Type    string `json:"type"`
        Code    string `json:"code"`
}

// Embed generates embeddings for multiple texts
func (c *OpenAIClient) Embed(ctx context.Context, texts []string) ([][]float32, error) <span class="cov10" title="7">{
        if len(texts) == 0 </span><span class="cov1" title="1">{
                return [][]float32{}, nil
        }</span>

        <span class="cov9" title="6">reqBody := openAIRequest{
                Input: texts,
                Model: c.Model,
        }

        bodyBytes, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov9" title="6">req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL, bytes.NewReader(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov9" title="6">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", c.APIKey))

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="5">defer resp.Body.Close()

        bodyBytes, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov8" title="5">if resp.StatusCode != http.StatusOK </span><span class="cov4" title="2">{
                var apiResp openAIResponse
                if err := json.Unmarshal(bodyBytes, &amp;apiResp); err == nil &amp;&amp; apiResp.Error != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("API error (%d): %s", resp.StatusCode, apiResp.Error.Message)
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("API error (%d): %s", resp.StatusCode, string(bodyBytes))</span>
        }

        <span class="cov6" title="3">var apiResp openAIResponse
        if err := json.Unmarshal(bodyBytes, &amp;apiResp); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov4" title="2">if apiResp.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s", apiResp.Error.Message)
        }</span>

        // Extract embeddings in correct order
        <span class="cov4" title="2">embeddings := make([][]float32, len(texts))
        for _, data := range apiResp.Data </span><span class="cov6" title="3">{
                if data.Index &gt;= len(embeddings) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid embedding index: %d", data.Index)
                }</span>
                <span class="cov6" title="3">embeddings[data.Index] = data.Embedding</span>
        }

        <span class="cov4" title="2">return embeddings, nil</span>
}

// EmbedOne generates an embedding for a single text
func (c *OpenAIClient) EmbedOne(ctx context.Context, text string) ([]float32, error) <span class="cov8" title="5">{
        embeddings, err := c.Embed(ctx, []string{text})
        if err != nil </span><span class="cov7" title="4">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(embeddings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no embeddings returned")
        }</span>

        <span class="cov1" title="1">return embeddings[0], nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package extraction provides entity and relationship extraction from text
package extraction

import (
        "context"
        "fmt"

        "github.com/dan-solli/gognee/pkg/llm"
)

// Entity represents a named entity extracted from text
type Entity struct {
        Name        string `json:"name"`
        Type        string `json:"type"`
        Description string `json:"description"`
}

// Valid entity types from the roadmap
var validEntityTypes = map[string]bool{
        "Person":     true,
        "Concept":    true,
        "System":     true,
        "Decision":   true,
        "Event":      true,
        "Technology": true,
        "Pattern":    true,
}

// entityExtractionPrompt is the prompt template for entity extraction
const entityExtractionPrompt = `You are a knowledge graph construction assistant.

Extract all meaningful entities from this text. For each entity, provide:
- name: The entity name
- type: One of [Person, Concept, System, Decision, Event, Technology, Pattern]
- description: Brief description (1 sentence)

Text:
---
%s
---

Return ONLY valid JSON array:
[{"name": "...", "type": "...", "description": "..."}, ...]`

// EntityExtractor extracts entities from text using an LLM
type EntityExtractor struct {
        LLM llm.LLMClient
}

// NewEntityExtractor creates a new entity extractor
func NewEntityExtractor(llmClient llm.LLMClient) *EntityExtractor <span class="cov9" title="17">{
        return &amp;EntityExtractor{
                LLM: llmClient,
        }
}</span>

// Extract extracts entities from the given text
func (e *EntityExtractor) Extract(ctx context.Context, text string) ([]Entity, error) <span class="cov9" title="17">{
        if text == "" </span><span class="cov1" title="1">{
                return []Entity{}, nil
        }</span>

        <span class="cov9" title="16">prompt := fmt.Sprintf(entityExtractionPrompt, text)

        var entities []Entity
        if err := e.LLM.CompleteWithSchema(ctx, prompt, &amp;entities); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to extract entities: %w", err)
        }</span>

        // Validate entities
        <span class="cov9" title="14">for i, entity := range entities </span><span class="cov10" title="19">{
                // Check required fields
                if entity.Name == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("entity at index %d has empty name", i)
                }</span>
                <span class="cov9" title="18">if entity.Type == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("entity at index %d (%s) has empty type", i, entity.Name)
                }</span>
                <span class="cov9" title="17">if entity.Description == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("entity at index %d (%s) has empty description", i, entity.Name)
                }</span>

                // Validate type against allowlist
                <span class="cov9" title="16">if !validEntityTypes[entity.Type] </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("entity at index %d (%s) has invalid type: %s (must be one of: Person, Concept, System, Decision, Event, Technology, Pattern)", i, entity.Name, entity.Type)
                }</span>
        }

        <span class="cov8" title="10">return entities, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package extraction

import (
        "context"
        "fmt"
        "strings"

        "github.com/dan-solli/gognee/pkg/llm"
)

// Triplet represents a relationship between two entities
type Triplet struct {
        Subject  string `json:"subject"`
        Relation string `json:"relation"`
        Object   string `json:"object"`
}

// relationExtractionPrompt is the prompt template for relationship extraction
const relationExtractionPrompt = `You are a knowledge graph construction assistant.

Given this text and the entities already extracted, identify relationships between them.
Express each relationship as a triplet: (subject, relation, object)

Use clear, consistent relation names like:
- USES, DEPENDS_ON, CREATED_BY, CONTAINS, IS_A, RELATES_TO, MENTIONS

Text:
---
%s
---

Known entities: %s

Return ONLY valid JSON array:
[{"subject": "...", "relation": "...", "object": "..."}, ...]`

// RelationExtractor extracts relationships between entities from text using an LLM
type RelationExtractor struct {
        LLM llm.LLMClient
}

// NewRelationExtractor creates a new relation extractor
func NewRelationExtractor(llmClient llm.LLMClient) *RelationExtractor <span class="cov8" title="19">{
        return &amp;RelationExtractor{
                LLM: llmClient,
        }
}</span>

// Extract extracts relationships from the given text using the provided entities
func (r *RelationExtractor) Extract(ctx context.Context, text string, entities []Entity) ([]Triplet, error) <span class="cov8" title="19">{
        // Return empty result for empty text or no entities
        if text == "" || len(entities) == 0 </span><span class="cov2" title="2">{
                return []Triplet{}, nil
        }</span>

        // Build entity names list for the prompt
        <span class="cov8" title="17">entityNames := buildEntityNamesList(entities)

        // Build the prompt
        prompt := fmt.Sprintf(relationExtractionPrompt, text, entityNames)

        // Call the LLM
        var triplets []Triplet
        if err := r.LLM.CompleteWithSchema(ctx, prompt, &amp;triplets); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to extract relationships: %w", err)
        }</span>

        // Build entity lookup map for case-insensitive matching
        <span class="cov7" title="15">entityLookup := buildEntityLookup(entities)

        // Validate and process triplets
        validatedTriplets, err := validateAndProcessTriplets(triplets, entityLookup)
        if err != nil </span><span class="cov5" title="5">{
                return nil, err
        }</span>

        // Deduplicate triplets
        <span class="cov6" title="10">result := deduplicateTriplets(validatedTriplets)

        return result, nil</span>
}

// buildEntityNamesList creates a comma-separated list of entity names for the prompt
func buildEntityNamesList(entities []Entity) string <span class="cov8" title="17">{
        names := make([]string, len(entities))
        for i, entity := range entities </span><span class="cov10" title="35">{
                names[i] = entity.Name
        }</span>
        <span class="cov8" title="17">return strings.Join(names, ", ")</span>
}

// buildEntityLookup creates a case-insensitive lookup map of entity names
func buildEntityLookup(entities []Entity) map[string]bool <span class="cov7" title="15">{
        lookup := make(map[string]bool)
        for _, entity := range entities </span><span class="cov9" title="33">{
                // Store lowercase version for case-insensitive matching
                lookup[strings.ToLower(strings.TrimSpace(entity.Name))] = true
        }</span>
        <span class="cov7" title="15">return lookup</span>
}

// validateAndProcessTriplets validates each triplet and ensures linking to known entities
func validateAndProcessTriplets(triplets []Triplet, entityLookup map[string]bool) ([]Triplet, error) <span class="cov7" title="15">{
        result := make([]Triplet, 0, len(triplets))

        for i, triplet := range triplets </span><span class="cov9" title="26">{
                // Trim whitespace
                subject := strings.TrimSpace(triplet.Subject)
                relation := strings.TrimSpace(triplet.Relation)
                object := strings.TrimSpace(triplet.Object)

                // Validate non-empty fields
                if subject == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("triplet at index %d has empty subject", i)
                }</span>
                <span class="cov9" title="25">if relation == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("triplet at index %d has empty relation", i)
                }</span>
                <span class="cov9" title="24">if object == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("triplet at index %d has empty object", i)
                }</span>

                // Strict mode: validate subject exists in entity list (case-insensitive)
                <span class="cov8" title="23">if !entityLookup[strings.ToLower(subject)] </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("triplet at index %d has unknown subject: %q (not in known entities)", i, subject)
                }</span>

                // Strict mode: validate object exists in entity list (case-insensitive)
                <span class="cov8" title="22">if !entityLookup[strings.ToLower(object)] </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("triplet at index %d has unknown object: %q (not in known entities)", i, object)
                }</span>

                // Add validated and trimmed triplet
                <span class="cov8" title="21">result = append(result, Triplet{
                        Subject:  subject,
                        Relation: relation,
                        Object:   object,
                })</span>
        }

        <span class="cov6" title="10">return result, nil</span>
}

// deduplicateTriplets removes duplicate triplets, preserving first occurrence order
// Comparison is case-insensitive for subject and object (matching entity linking behavior)
func deduplicateTriplets(triplets []Triplet) []Triplet <span class="cov6" title="10">{
        seen := make(map[string]bool)
        result := make([]Triplet, 0, len(triplets))

        for _, triplet := range triplets </span><span class="cov8" title="21">{
                // Create a normalized key for comparison (case-insensitive)
                key := strings.ToLower(triplet.Subject) + "|" +
                        strings.ToLower(triplet.Relation) + "|" +
                        strings.ToLower(triplet.Object)

                if !seen[key] </span><span class="cov7" title="14">{
                        seen[key] = true
                        result = append(result, triplet)
                }</span>
        }

        <span class="cov6" title="10">return result</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gognee

import (
        "math"
        "time"
)

// calculateDecay computes the exponential decay multiplier for a node based on its age.
// Uses the formula: score_multiplier = 0.5^(age_days / half_life_days)
//
// Parameters:
//   - nodeAge: The age of the node (time since creation or last access)
//   - halfLifeDays: The number of days after which the score is halved
//
// Returns:
//   - A multiplier between 0 and 1 to apply to the node's search score
//   - Returns 1.0 for negative ages (defensive)
//   - Returns 1.0 for zero half-life (defensive)
func calculateDecay(nodeAge time.Duration, halfLifeDays int) float64 <span class="cov10" title="10">{
        // Handle edge cases
        if nodeAge &lt; 0 </span><span class="cov1" title="1">{
                return 1.0 // No decay for negative age (shouldn't happen but be defensive)
        }</span>
        <span class="cov9" title="9">if halfLifeDays &lt;= 0 </span><span class="cov1" title="1">{
                return 1.0 // No decay for zero/negative half-life
        }</span>

        // Convert nodeAge to days (float64 for precision)
        <span class="cov9" title="8">ageDays := nodeAge.Hours() / 24.0

        // Apply exponential decay formula: 0.5^(age_days / half_life_days)
        exponent := ageDays / float64(halfLifeDays)
        multiplier := math.Pow(0.5, exponent)

        return multiplier</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package gognee provides a knowledge graph memory system for AI assistants
package gognee

import (
        "context"
        "crypto/sha256"
        "fmt"
        "strings"
        "time"

        "github.com/dan-solli/gognee/pkg/chunker"
        "github.com/dan-solli/gognee/pkg/embeddings"
        "github.com/dan-solli/gognee/pkg/extraction"
        "github.com/dan-solli/gognee/pkg/llm"
        "github.com/dan-solli/gognee/pkg/search"
        "github.com/dan-solli/gognee/pkg/store"
)

// Config holds configuration for the Gognee system
type Config struct {
        // OpenAI API key for embeddings and LLM
        OpenAIKey string

        // Embedding model (default: "text-embedding-3-small")
        EmbeddingModel string

        // LLM model for entity extraction (default: "gpt-4o-mini")
        LLMModel string

        // Chunk size in tokens (default: 512)
        ChunkSize int

        // Chunk overlap in tokens (default: 50)
        ChunkOverlap int

        // DBPath is the path to the SQLite database file.
        // If empty or ":memory:", an in-memory database is used.
        DBPath string

        // DecayEnabled enables time-based memory decay scoring (default: false)
        DecayEnabled bool

        // DecayHalfLifeDays is the number of days after which a node's score is halved (default: 30)
        DecayHalfLifeDays int

        // DecayBasis determines decay calculation: "access" (last access time) or "creation" (creation time)
        // Default: "access"
        DecayBasis string
}

// Gognee is the main entry point for the memory system
type Gognee struct {
        config            Config
        chunker           *chunker.Chunker
        embeddings        embeddings.EmbeddingClient
        llm               llm.LLMClient
        graphStore        store.GraphStore
        vectorStore       store.VectorStore
        searcher          search.Searcher
        entityExtractor   *extraction.EntityExtractor
        relationExtractor *extraction.RelationExtractor
        buffer            []AddedDocument
        lastCognified     time.Time
}

// AddedDocument represents a document added to the buffer for processing
type AddedDocument struct {
        Text    string
        Source  string
        AddedAt time.Time
}

// AddOptions configures the Add() method
type AddOptions struct {
        Source string
}

// CognifyOptions configures the Cognify() method
type CognifyOptions struct {
        // Reserved for future options like ChunkSize override
}

// CognifyResult reports the outcome of a Cognify() operation
type CognifyResult struct {
        DocumentsProcessed int
        ChunksProcessed    int
        ChunksFailed       int
        NodesCreated       int
        EdgesCreated       int
        Errors             []error
}

// Stats reports basic telemetry about the knowledge graph
type Stats struct {
        NodeCount     int64
        EdgeCount     int64
        BufferedDocs  int
        LastCognified time.Time
}

// PruneOptions configures the Prune() method
type PruneOptions struct {
        // MaxAgeDays prunes nodes older than this many days (based on decay basis).
        // If zero, this criterion is not used.
        MaxAgeDays int

        // MinDecayScore prunes nodes with decay score below this threshold.
        // If zero, this criterion is not used.
        // Score is calculated using current decay settings.
        MinDecayScore float64

        // DryRun reports what would be pruned without actually deleting.
        DryRun bool
}

// PruneResult reports the outcome of a Prune() operation
type PruneResult struct {
        NodesEvaluated int      // Total number of nodes considered
        NodesPruned    int      // Number of nodes deleted
        EdgesPruned    int      // Number of edges deleted (via cascade)
        NodeIDs        []string // IDs of pruned nodes (for verification)
}

// New creates a new Gognee instance
func New(cfg Config) (*Gognee, error) <span class="cov10" title="24">{
        // Apply defaults
        if cfg.ChunkSize == 0 </span><span class="cov9" title="23">{
                cfg.ChunkSize = 512
        }</span>
        <span class="cov10" title="24">if cfg.ChunkOverlap == 0 </span><span class="cov9" title="23">{
                cfg.ChunkOverlap = 50
        }</span>
        <span class="cov10" title="24">if cfg.DecayBasis == "" </span><span class="cov9" title="21">{
                cfg.DecayBasis = "access"
        }</span>

        // Validate decay configuration (before applying half-life default)
        <span class="cov10" title="24">if cfg.DecayEnabled </span><span class="cov4" title="4">{
                if cfg.DecayHalfLifeDays &lt; 0 </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("DecayHalfLifeDays must be positive, got %d", cfg.DecayHalfLifeDays)
                }</span>
                <span class="cov4" title="3">if cfg.DecayBasis != "access" &amp;&amp; cfg.DecayBasis != "creation" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("DecayBasis must be 'access' or 'creation', got %q", cfg.DecayBasis)
                }</span>
        }

        // Apply half-life default after validation
        <span class="cov9" title="22">if cfg.DecayHalfLifeDays == 0 </span><span class="cov9" title="20">{
                cfg.DecayHalfLifeDays = 30
        }</span>

        // Initialize chunker
        <span class="cov9" title="22">c := &amp;chunker.Chunker{
                MaxTokens: cfg.ChunkSize,
                Overlap:   cfg.ChunkOverlap,
        }

        // Initialize embeddings client
        embeddingsClient := embeddings.NewOpenAIClient(cfg.OpenAIKey)
        if cfg.EmbeddingModel != "" </span><span class="cov1" title="1">{
                embeddingsClient.Model = cfg.EmbeddingModel
        }</span>

        // Initialize LLM client
        <span class="cov9" title="22">llmClient := llm.NewOpenAILLM(cfg.OpenAIKey)
        if cfg.LLMModel != "" </span><span class="cov1" title="1">{
                llmClient.Model = cfg.LLMModel
        }</span>

        // Initialize GraphStore
        <span class="cov9" title="22">dbPath := cfg.DBPath
        if dbPath == "" </span><span class="cov1" title="1">{
                dbPath = ":memory:"
        }</span>
        <span class="cov9" title="22">graphStore, err := store.NewSQLiteGraphStore(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize graph store: %w", err)
        }</span>

        // Initialize VectorStore
        // Use SQLiteVectorStore for persistent databases, MemoryVectorStore for :memory:
        <span class="cov9" title="22">var vectorStore store.VectorStore
        if dbPath == ":memory:" </span><span class="cov9" title="22">{
                vectorStore = store.NewMemoryVectorStore()
        }</span> else<span class="cov0" title="0"> {
                // Share the database connection from GraphStore
                vectorStore = store.NewSQLiteVectorStore(graphStore.DB())
        }</span>

        // Initialize extractors
        <span class="cov9" title="22">entityExtractor := extraction.NewEntityExtractor(llmClient)
        relationExtractor := extraction.NewRelationExtractor(llmClient)

        // Initialize searcher
        baseSearcher := search.NewHybridSearcher(embeddingsClient, vectorStore, graphStore)

        // Wrap with DecayingSearcher if decay is enabled
        var searcher search.Searcher
        if cfg.DecayEnabled </span><span class="cov2" title="2">{
                searcher = search.NewDecayingSearcher(baseSearcher, graphStore, cfg.DecayEnabled, cfg.DecayHalfLifeDays, cfg.DecayBasis)
        }</span> else<span class="cov9" title="20"> {
                searcher = baseSearcher
        }</span>

        <span class="cov9" title="22">return &amp;Gognee{
                config:            cfg,
                chunker:           c,
                embeddings:        embeddingsClient,
                llm:               llmClient,
                graphStore:        graphStore,
                vectorStore:       vectorStore,
                searcher:          searcher,
                entityExtractor:   entityExtractor,
                relationExtractor: relationExtractor,
                buffer:            make([]AddedDocument, 0),
                lastCognified:     time.Time{},
        }, nil</span>
}

// GetChunker returns the configured chunker
func (g *Gognee) GetChunker() *chunker.Chunker <span class="cov5" title="5">{
        return g.chunker
}</span>

// GetEmbeddings returns the configured embeddings client
func (g *Gognee) GetEmbeddings() embeddings.EmbeddingClient <span class="cov2" title="2">{
        return g.embeddings
}</span>

// GetLLM returns the configured LLM client
func (g *Gognee) GetLLM() llm.LLMClient <span class="cov2" title="2">{
        return g.llm
}</span>

// GetGraphStore returns the configured graph store
func (g *Gognee) GetGraphStore() store.GraphStore <span class="cov1" title="1">{
        return g.graphStore
}</span>

// GetVectorStore returns the configured vector store
func (g *Gognee) GetVectorStore() store.VectorStore <span class="cov1" title="1">{
        return g.vectorStore
}</span>

// Add buffers text for processing via Cognify()
func (g *Gognee) Add(ctx context.Context, text string, opts AddOptions) error <span class="cov8" title="12">{
        if strings.TrimSpace(text) == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("text cannot be empty")
        }</span>

        <span class="cov7" title="10">doc := AddedDocument{
                Text:    text,
                Source:  opts.Source,
                AddedAt: time.Now(),
        }
        g.buffer = append(g.buffer, doc)
        return nil</span>
}

// BufferedCount returns the number of documents currently in the buffer
func (g *Gognee) BufferedCount() int <span class="cov5" title="5">{
        return len(g.buffer)
}</span>

// Cognify processes all buffered documents through the extraction pipeline
func (g *Gognee) Cognify(ctx context.Context, opts CognifyOptions) (*CognifyResult, error) <span class="cov6" title="7">{
        result := &amp;CognifyResult{
                Errors: make([]error, 0),
        }

        // No-op if buffer is empty
        if len(g.buffer) == 0 </span><span class="cov1" title="1">{
                return result, nil
        }</span>

        // Process each document
        <span class="cov6" title="6">for _, doc := range g.buffer </span><span class="cov6" title="6">{
                result.DocumentsProcessed++

                // Chunk the text
                chunks := g.chunker.Chunk(doc.Text)

                // Process each chunk
                for _, chunk := range chunks </span><span class="cov6" title="6">{
                        result.ChunksProcessed++

                        // Extract entities
                        entities, err := g.entityExtractor.Extract(ctx, chunk.Text)
                        if err != nil </span><span class="cov1" title="1">{
                                result.ChunksFailed++
                                result.Errors = append(result.Errors, fmt.Errorf("entity extraction failed for chunk %s: %w", chunk.ID, err))
                                continue</span>
                        }

                        // Extract relations
                        <span class="cov5" title="5">triplets, err := g.relationExtractor.Extract(ctx, chunk.Text, entities)
                        if err != nil </span><span class="cov0" title="0">{
                                result.ChunksFailed++
                                result.Errors = append(result.Errors, fmt.Errorf("relation extraction failed for chunk %s: %w", chunk.ID, err))
                                // Continue with entities only if relations fail
                        }</span>

                        // Create nodes for each entity
                        <span class="cov5" title="5">for _, entity := range entities </span><span class="cov6" title="6">{
                                nodeID := generateDeterministicNodeID(entity.Name, entity.Type)
                                node := &amp;store.Node{
                                        ID:          nodeID,
                                        Name:        entity.Name,
                                        Type:        entity.Type,
                                        Description: entity.Description,
                                        CreatedAt:   time.Now(),
                                        Metadata:    make(map[string]interface{}),
                                }

                                // Add to graph store
                                if err := g.graphStore.AddNode(ctx, node); err != nil </span><span class="cov1" title="1">{
                                        result.Errors = append(result.Errors, fmt.Errorf("failed to add node %s: %w", entity.Name, err))
                                        continue</span>
                                }
                                <span class="cov5" title="5">result.NodesCreated++

                                // Generate embedding for the node
                                embedding, err := g.embeddings.EmbedOne(ctx, entity.Name+" "+entity.Description)
                                if err != nil </span><span class="cov1" title="1">{
                                        result.Errors = append(result.Errors, fmt.Errorf("failed to embed node %s: %w", entity.Name, err))
                                        continue</span>
                                }

                                // Update node with embedding
                                <span class="cov4" title="4">node.Embedding = embedding
                                if err := g.graphStore.AddNode(ctx, node); err != nil </span><span class="cov0" title="0">{
                                        result.Errors = append(result.Errors, fmt.Errorf("failed to update node embedding %s: %w", entity.Name, err))
                                        continue</span>
                                }

                                // Index in vector store
                                <span class="cov4" title="4">if err := g.vectorStore.Add(ctx, nodeID, embedding); err != nil </span><span class="cov1" title="1">{
                                        result.Errors = append(result.Errors, fmt.Errorf("failed to index node %s in vector store: %w", entity.Name, err))
                                }</span>
                        }

                        // Create edges for each triplet
                        <span class="cov5" title="5">for _, triplet := range triplets </span><span class="cov1" title="1">{
                                sourceID := generateDeterministicNodeID(triplet.Subject, "")
                                targetID := generateDeterministicNodeID(triplet.Object, "")

                                edge := &amp;store.Edge{
                                        ID:        fmt.Sprintf("%s-%s-%s", sourceID, sanitizeRelation(triplet.Relation), targetID),
                                        SourceID:  sourceID,
                                        Relation:  triplet.Relation,
                                        TargetID:  targetID,
                                        Weight:    1.0,
                                        CreatedAt: time.Now(),
                                }

                                if err := g.graphStore.AddEdge(ctx, edge); err != nil </span><span class="cov1" title="1">{
                                        result.Errors = append(result.Errors, fmt.Errorf("failed to add edge %s-%s-%s: %w", triplet.Subject, triplet.Relation, triplet.Object, err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">result.EdgesCreated++</span>
                        }
                }
        }

        // Always clear buffer after processing (best-effort semantics)
        <span class="cov6" title="6">g.buffer = make([]AddedDocument, 0)
        g.lastCognified = time.Now()

        return result, nil</span>
}

// Search queries the knowledge graph
func (g *Gognee) Search(ctx context.Context, query string, opts search.SearchOptions) ([]search.SearchResult, error) <span class="cov1" title="1">{
        search.ApplyDefaults(&amp;opts)
        results, err := g.searcher.Search(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update access times for returned results (for decay reinforcement)
        // Only update if we have results
        <span class="cov1" title="1">if len(results) &gt; 0 </span><span class="cov0" title="0">{
                nodeIDs := make([]string, len(results))
                for i, result := range results </span><span class="cov0" title="0">{
                        nodeIDs[i] = result.NodeID
                }</span>

                // Cast to SQLiteGraphStore to access UpdateAccessTime
                // This is safe because we control the concrete type in New()
                <span class="cov0" title="0">if sqlStore, ok := g.graphStore.(*store.SQLiteGraphStore); ok </span><span class="cov0" title="0">{
                        // Best-effort update - don't fail search if access tracking fails
                        _ = sqlStore.UpdateAccessTime(ctx, nodeIDs)
                }</span>
        }

        <span class="cov1" title="1">return results, nil</span>
}

// Close releases all resources
func (g *Gognee) Close() error <span class="cov9" title="22">{
        g.buffer = make([]AddedDocument, 0)
        return g.graphStore.Close()
}</span>

// Stats returns basic telemetry
func (g *Gognee) Stats() (Stats, error) <span class="cov4" title="3">{
        ctx := context.Background()
        nodeCount, err := g.graphStore.NodeCount(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return Stats{}, fmt.Errorf("failed to get node count: %w", err)
        }</span>

        <span class="cov4" title="3">edgeCount, err := g.graphStore.EdgeCount(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return Stats{}, fmt.Errorf("failed to get edge count: %w", err)
        }</span>

        <span class="cov4" title="3">return Stats{
                NodeCount:     nodeCount,
                EdgeCount:     edgeCount,
                BufferedDocs:  len(g.buffer),
                LastCognified: g.lastCognified,
        }, nil</span>
}

// Prune removes old or low-scoring nodes from the knowledge graph.
// Edges connected to pruned nodes are also deleted (cascade).
// Use DryRun to preview what would be pruned without actually deleting.
func (g *Gognee) Prune(ctx context.Context, opts PruneOptions) (*PruneResult, error) <span class="cov4" title="4">{
        result := &amp;PruneResult{
                NodeIDs: make([]string, 0),
        }

        // Get all nodes for evaluation
        sqlStore, ok := g.graphStore.(*store.SQLiteGraphStore)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("prune requires SQLiteGraphStore")
        }</span>

        // Query all nodes
        <span class="cov4" title="4">allNodes, err := sqlStore.GetAllNodes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get nodes: %w", err)
        }</span>

        <span class="cov4" title="4">result.NodesEvaluated = len(allNodes)

        // Evaluate each node for pruning
        now := time.Now()
        nodesToPrune := make([]string, 0)

        for _, node := range allNodes </span><span class="cov7" title="9">{
                shouldPrune := false

                // Check MaxAgeDays criterion
                if opts.MaxAgeDays &gt; 0 </span><span class="cov7" title="9">{
                        var age time.Duration
                        if g.config.DecayBasis == "access" &amp;&amp; node.LastAccessedAt != nil </span><span class="cov0" title="0">{
                                age = now.Sub(*node.LastAccessedAt)
                        }</span> else<span class="cov7" title="9"> {
                                age = now.Sub(node.CreatedAt)
                        }</span>

                        <span class="cov7" title="9">ageDays := int(age.Hours() / 24)
                        if ageDays &gt; opts.MaxAgeDays </span><span class="cov5" title="5">{
                                shouldPrune = true
                        }</span>
                }

                // Check MinDecayScore criterion
                <span class="cov7" title="9">if opts.MinDecayScore &gt; 0 &amp;&amp; g.config.DecayEnabled </span><span class="cov0" title="0">{
                        var age time.Duration
                        if g.config.DecayBasis == "access" &amp;&amp; node.LastAccessedAt != nil </span><span class="cov0" title="0">{
                                age = now.Sub(*node.LastAccessedAt)
                        }</span> else<span class="cov0" title="0"> {
                                age = now.Sub(node.CreatedAt)
                        }</span>

                        <span class="cov0" title="0">decayScore := calculateDecay(age, g.config.DecayHalfLifeDays)
                        if decayScore &lt; opts.MinDecayScore </span><span class="cov0" title="0">{
                                shouldPrune = true
                        }</span>
                }

                <span class="cov7" title="9">if shouldPrune </span><span class="cov5" title="5">{
                        nodesToPrune = append(nodesToPrune, node.ID)
                }</span>
        }

        <span class="cov4" title="4">result.NodesPruned = len(nodesToPrune)
        result.NodeIDs = nodesToPrune

        // If dry run, stop here
        if opts.DryRun </span><span class="cov1" title="1">{
                // Estimate edges that would be pruned
                for _, nodeID := range nodesToPrune </span><span class="cov2" title="2">{
                        edges, err := g.graphStore.GetEdges(ctx, nodeID)
                        if err == nil </span><span class="cov2" title="2">{
                                result.EdgesPruned += len(edges)
                        }</span>
                }
                <span class="cov1" title="1">return result, nil</span>
        }

        // Actually prune nodes and edges
        <span class="cov4" title="3">for _, nodeID := range nodesToPrune </span><span class="cov4" title="3">{
                // Delete edges first (cascade)
                edges, err := g.graphStore.GetEdges(ctx, nodeID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="3">result.EdgesPruned += len(edges)

                // Delete the edges
                for _, edge := range edges </span><span class="cov2" title="2">{
                        if err := sqlStore.DeleteEdge(ctx, edge.ID); err != nil </span><span class="cov0" title="0">{
                                // Continue on error to prune as much as possible
                                continue</span>
                        }
                }

                // Delete from vector store
                <span class="cov4" title="3">if err := g.vectorStore.Delete(ctx, nodeID); err != nil </span>{<span class="cov0" title="0">
                        // Continue on error
                }</span>

                // Delete the node
                <span class="cov4" title="3">if err := sqlStore.DeleteNode(ctx, nodeID); err != nil </span><span class="cov0" title="0">{
                        // Continue on error
                        continue</span>
                }
        }

        <span class="cov4" title="3">return result, nil</span>
}

// generateDeterministicNodeID creates a deterministic node ID from name and type
func generateDeterministicNodeID(name, nodeType string) string <span class="cov10" title="24">{
        // Normalize the name
        normalized := strings.ToLower(strings.TrimSpace(name))
        normalized = strings.Join(strings.Fields(normalized), " ") // Collapse spaces

        // Create the key
        key := normalized + "|" + nodeType

        // Hash with SHA-256
        hash := sha256.Sum256([]byte(key))

        // Return hex-encoded first 16 bytes (32 chars)
        return fmt.Sprintf("%x", hash[:16])
}</span>

// sanitizeRelation converts relation names to safe edge IDs
func sanitizeRelation(relation string) string <span class="cov2" title="2">{
        return strings.ToUpper(strings.ReplaceAll(relation, " ", "_"))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "regexp"
        "strings"
        "time"
)

const (
        defaultOpenAIBaseURL = "https://api.openai.com/v1"
        defaultModel         = "gpt-4o-mini"
        maxRetries           = 3
        initialRetryDelay    = 1 * time.Second
        backoffFactor        = 2.0
)

// OpenAILLM implements LLMClient for OpenAI's Chat Completions API
type OpenAILLM struct {
        APIKey  string
        Model   string
        BaseURL string
        client  *http.Client
}

// NewOpenAILLM creates a new OpenAI LLM client
func NewOpenAILLM(apiKey string) *OpenAILLM <span class="cov8" title="12">{
        return &amp;OpenAILLM{
                APIKey:  apiKey,
                Model:   defaultModel,
                BaseURL: defaultOpenAIBaseURL,
                client:  &amp;http.Client{Timeout: 60 * time.Second},
        }
}</span>

type openAIRequest struct {
        Model    string    `json:"model"`
        Messages []message `json:"messages"`
}

type message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type openAIResponse struct {
        Choices []struct {
                Message message `json:"message"`
        } `json:"choices"`
        Error *struct {
                Message string `json:"message"`
                Type    string `json:"type"`
        } `json:"error,omitempty"`
}

// Complete sends a prompt to the OpenAI Chat Completions API and returns the response
func (o *OpenAILLM) Complete(ctx context.Context, prompt string) (string, error) <span class="cov8" title="12">{
        var lastErr error
        delay := initialRetryDelay

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov10" title="18">{
                if attempt &gt; 0 </span><span class="cov6" title="6">{
                        // Add jitter to delay: random value between 0.5x and 1.5x of delay
                        jitter := delay/2 + time.Duration(rand.Int63n(int64(delay)))
                        select </span>{
                        case &lt;-time.After(jitter):<span class="cov6" title="6"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return "", ctx.Err()</span>
                        }
                        <span class="cov6" title="6">delay = time.Duration(float64(delay) * backoffFactor)</span>
                }

                <span class="cov10" title="18">result, err := o.makeRequest(ctx, prompt)
                if err == nil </span><span class="cov6" title="6">{
                        return result, nil
                }</span>

                <span class="cov8" title="12">lastErr = err

                // Check if we should retry
                if !shouldRetry(err) </span><span class="cov5" title="4">{
                        return "", err
                }</span>

                // Check if context is cancelled
                <span class="cov7" title="8">if ctx.Err() != nil </span><span class="cov1" title="1">{
                        return "", ctx.Err()
                }</span>
        }

        <span class="cov1" title="1">return "", fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)</span>
}

// CompleteWithSchema sends a prompt and unmarshals the JSON response into the provided schema
func (o *OpenAILLM) CompleteWithSchema(ctx context.Context, prompt string, schema any) error <span class="cov4" title="3">{
        response, err := o.Complete(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Strip markdown code fences if present (LLM sometimes wraps JSON in ```json ... ```)
        <span class="cov4" title="3">cleaned := stripMarkdownCodeFence(response)

        if err := json.Unmarshal([]byte(cleaned), schema); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to unmarshal LLM response: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// stripMarkdownCodeFence removes markdown code fences from LLM responses.
// Handles formats like: ```json\n...\n``` or ```\n...\n```
func stripMarkdownCodeFence(s string) string <span class="cov7" title="9">{
        s = strings.TrimSpace(s)

        // Regex to match ```json or ``` at start, and ``` at end
        // Pattern: optional ```json or ```, content, optional ```
        re := regexp.MustCompile("(?s)^```(?:json)?\\s*\n?(.*?)\\s*```$")
        if matches := re.FindStringSubmatch(s); len(matches) == 2 </span><span class="cov6" title="5">{
                return strings.TrimSpace(matches[1])
        }</span>

        <span class="cov5" title="4">return s</span>
}

func (o *OpenAILLM) makeRequest(ctx context.Context, prompt string) (string, error) <span class="cov10" title="18">{
        reqBody := openAIRequest{
                Model: o.Model,
                Messages: []message{
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov10" title="18">req, err := http.NewRequestWithContext(ctx, "POST", o.BaseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov10" title="18">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+o.APIKey)

        resp, err := o.client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return "", &amp;retryableError{err: fmt.Errorf("request failed: %w", err)}
        }</span>
        <span class="cov9" title="17">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Handle non-200 status codes
        <span class="cov9" title="17">if resp.StatusCode != http.StatusOK </span><span class="cov7" title="8">{
                // Retry on 429 (rate limit) and 5xx errors
                if resp.StatusCode == http.StatusTooManyRequests || resp.StatusCode &gt;= 500 </span><span class="cov7" title="7">{
                        return "", &amp;retryableError{err: fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))}
                }</span>
                <span class="cov1" title="1">return "", fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))</span>
        }

        <span class="cov7" title="9">var apiResp openAIResponse
        if err := json.Unmarshal(body, &amp;apiResp); err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov7" title="8">if apiResp.Error != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("OpenAI API error: %s", apiResp.Error.Message)
        }</span>

        <span class="cov7" title="7">if len(apiResp.Choices) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no completion choices returned")
        }</span>

        <span class="cov6" title="6">return apiResp.Choices[0].Message.Content, nil</span>
}

// retryableError indicates an error that should be retried
type retryableError struct {
        err error
}

func (e *retryableError) Error() string <span class="cov1" title="1">{
        return e.err.Error()
}</span>

func (e *retryableError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func shouldRetry(err error) bool <span class="cov8" title="12">{
        var retryErr *retryableError
        // Use type assertion to check for retryableError
        if re, ok := err.(*retryableError); ok </span><span class="cov7" title="8">{
                retryErr = re
        }</span>
        <span class="cov8" title="12">return retryErr != nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package search

import (
        "context"
        "math"
        "time"

        "github.com/dan-solli/gognee/pkg/store"
)

// DecayingSearcher is a decorator that applies time-based decay to search results.
// It wraps any Searcher implementation and modifies scores based on node age.
type DecayingSearcher struct {
        underlying   Searcher
        graphStore   store.GraphStore
        enabled      bool
        halfLifeDays int
        basis        string // "access" or "creation"
}

// NewDecayingSearcher creates a new decaying searcher wrapper.
//
// Parameters:
//   - underlying: The base searcher to wrap
//   - graphStore: Graph store for retrieving node timestamps
//   - enabled: Whether decay is enabled
//   - halfLifeDays: Number of days for half-life decay
//   - basis: "access" (use last_accessed_at) or "creation" (use created_at)
func NewDecayingSearcher(
        underlying Searcher,
        graphStore store.GraphStore,
        enabled bool,
        halfLifeDays int,
        basis string,
) *DecayingSearcher <span class="cov10" title="5">{
        return &amp;DecayingSearcher{
                underlying:   underlying,
                graphStore:   graphStore,
                enabled:      enabled,
                halfLifeDays: halfLifeDays,
                basis:        basis,
        }
}</span>

// Search performs search with decay applied to scores.
func (d *DecayingSearcher) Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error) <span class="cov10" title="5">{
        // Get underlying search results
        results, err := d.underlying.Search(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If decay is disabled, return results as-is
        <span class="cov10" title="5">if !d.enabled </span><span class="cov1" title="1">{
                return results, nil
        }</span>

        // Apply decay to each result
        <span class="cov8" title="4">now := time.Now()
        decayedResults := make([]SearchResult, 0, len(results))

        for _, result := range results </span><span class="cov10" title="5">{
                // Fetch node to get timestamps
                node, err := d.graphStore.GetNode(ctx, result.NodeID)
                if err != nil </span><span class="cov0" title="0">{
                        // On error, skip decay for this node but include it
                        decayedResults = append(decayedResults, result)
                        continue</span>
                }
                <span class="cov10" title="5">if node == nil </span><span class="cov0" title="0">{
                        // Node was deleted, skip it
                        continue</span>
                }

                // Determine age based on decay basis
                <span class="cov10" title="5">var age time.Duration
                if d.basis == "access" &amp;&amp; node.LastAccessedAt != nil </span><span class="cov7" title="3">{
                        // Use last access time
                        age = now.Sub(*node.LastAccessedAt)
                }</span> else<span class="cov4" title="2"> {
                        // Fall back to creation time (if access-based but never accessed, or creation-based)
                        age = now.Sub(node.CreatedAt)
                }</span>

                // Calculate decay multiplier
                <span class="cov10" title="5">decayMultiplier := d.calculateDecay(age)

                // Apply decay to score
                result.Score = result.Score * decayMultiplier

                // Optional: filter out results below minimum threshold
                // For now, keep all results (even very low scores)
                if result.Score &lt; 0.001 </span><span class="cov1" title="1">{
                        // Skip nodes with extremely low scores
                        continue</span>
                }

                <span class="cov8" title="4">decayedResults = append(decayedResults, result)</span>
        }

        <span class="cov8" title="4">return decayedResults, nil</span>
}

// calculateDecay computes the exponential decay multiplier.
// Formula: 0.5^(age_days / half_life_days)
func (d *DecayingSearcher) calculateDecay(age time.Duration) float64 <span class="cov10" title="5">{
        if age &lt; 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov10" title="5">if d.halfLifeDays &lt;= 0 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov10" title="5">ageDays := age.Hours() / 24.0
        exponent := ageDays / float64(d.halfLifeDays)
        return math.Pow(0.5, exponent)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package search

import (
        "context"
        "errors"
        "sort"

        "github.com/dan-solli/gognee/pkg/store"
)

// ErrNoSeeds is returned when graph search is attempted without seed nodes.
var ErrNoSeeds = errors.New("graph search requires seed node IDs in SearchOptions.SeedNodeIDs")

// GraphSearcher performs graph traversal search from seed nodes.
type GraphSearcher struct {
        graphStore store.GraphStore
}

// NewGraphSearcher creates a new graph searcher.
func NewGraphSearcher(graphStore store.GraphStore) *GraphSearcher <span class="cov6" title="6">{
        return &amp;GraphSearcher{
                graphStore: graphStore,
        }
}</span>

// Search performs graph traversal from seed nodes.
// The query parameter is ignored (graph search uses opts.SeedNodeIDs).
func (g *GraphSearcher) Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error) <span class="cov6" title="6">{
        ApplyDefaults(&amp;opts)

        if len(opts.SeedNodeIDs) == 0 </span><span class="cov1" title="1">{
                return nil, ErrNoSeeds
        }</span>

        // Track nodes and their best scores
        <span class="cov6" title="5">nodeScores := make(map[string]nodeScore)
        visited := make(map[string]bool)

        // BFS traversal from all seeds
        type queueItem struct {
                nodeID string
                depth  int
        }
        queue := make([]queueItem, 0)

        // Initialize with seeds
        for _, seedID := range opts.SeedNodeIDs </span><span class="cov6" title="6">{
                seedNode, err := g.graphStore.GetNode(ctx, seedID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="6">if seedNode != nil </span><span class="cov6" title="6">{
                        updateNodeScore(nodeScores, seedID, seedNode, 0)
                        queue = append(queue, queueItem{seedID, 0})
                        visited[seedID] = true
                }</span>
        }

        // BFS traversal
        <span class="cov6" title="5">for len(queue) &gt; 0 </span><span class="cov9" title="15">{
                current := queue[0]
                queue = queue[1:]

                // Stop if we've reached max depth
                if current.depth &gt;= opts.GraphDepth </span><span class="cov6" title="5">{
                        continue</span>
                }

                // Get direct neighbors (depth=1 from current node)
                <span class="cov8" title="10">neighbors, err := g.graphStore.GetNeighbors(ctx, current.nodeID, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="10">nextDepth := current.depth + 1
                for _, neighbor := range neighbors </span><span class="cov8" title="11">{
                        updateNodeScore(nodeScores, neighbor.ID, neighbor, nextDepth)

                        // Add to queue if not visited
                        if !visited[neighbor.ID] </span><span class="cov7" title="9">{
                                visited[neighbor.ID] = true
                                queue = append(queue, queueItem{neighbor.ID, nextDepth})
                        }</span>
                }
        }

        // Convert to results and sort
        <span class="cov6" title="5">results := make([]SearchResult, 0, len(nodeScores))
        for nodeID, ns := range nodeScores </span><span class="cov9" title="15">{
                results = append(results, SearchResult{
                        NodeID:     nodeID,
                        Node:       ns.node,
                        Score:      ns.score,
                        Source:     "graph",
                        GraphDepth: ns.depth,
                })
        }</span>

        // Sort by score descending
        <span class="cov6" title="5">sort.Slice(results, func(i, j int) bool </span><span class="cov8" title="11">{
                return results[i].Score &gt; results[j].Score
        }</span>)

        // Apply TopK limit
        <span class="cov6" title="5">if len(results) &gt; opts.TopK </span><span class="cov0" title="0">{
                results = results[:opts.TopK]
        }</span>

        <span class="cov6" title="5">return results, nil</span>
}

type nodeScore struct {
        node  *store.Node
        score float64
        depth int
}

func updateNodeScore(scores map[string]nodeScore, nodeID string, node *store.Node, depth int) <span class="cov10" title="17">{
        score := 1.0 / float64(1+depth)

        if existing, found := scores[nodeID]; found </span><span class="cov3" title="2">{
                // Keep best score (shortest path)
                if score &gt; existing.score </span><span class="cov0" title="0">{
                        scores[nodeID] = nodeScore{
                                node:  node,
                                score: score,
                                depth: depth,
                        }
                }</span>
        } else<span class="cov9" title="15"> {
                scores[nodeID] = nodeScore{
                        node:  node,
                        score: score,
                        depth: depth,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package search

import (
        "context"
        "math"
        "sort"

        "github.com/dan-solli/gognee/pkg/embeddings"
        "github.com/dan-solli/gognee/pkg/store"
)

// HybridSearcher combines vector similarity and graph traversal search.
type HybridSearcher struct {
        embeddings  embeddings.EmbeddingClient
        vectorStore store.VectorStore
        graphStore  store.GraphStore
}

// NewHybridSearcher creates a new hybrid searcher.
func NewHybridSearcher(
        embClient embeddings.EmbeddingClient,
        vectorStore store.VectorStore,
        graphStore store.GraphStore,
) *HybridSearcher <span class="cov6" title="6">{
        return &amp;HybridSearcher{
                embeddings:  embClient,
                vectorStore: vectorStore,
                graphStore:  graphStore,
        }
}</span>

// Search performs hybrid search combining vector similarity and graph expansion.
// Score formula: combined_score = vector_score + graph_score
// where vector_score = 0 if not found by vector, graph_score = 0 if not found by graph.
func (h *HybridSearcher) Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error) <span class="cov6" title="6">{
        ApplyDefaults(&amp;opts)

        // Step 1: Embed the query
        embedding, err := h.embeddings.EmbedOne(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Step 2: Vector search for initial results
        // Fetch more than TopK to ensure adequate expansion base
        <span class="cov6" title="6">initialFetch := int(math.Max(float64(opts.TopK*2), 20))
        vectorResults, err := h.vectorStore.Search(ctx, embedding, initialFetch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Track combined scores and metadata
        <span class="cov6" title="6">type nodeInfo struct {
                node        *store.Node
                vectorScore float64
                graphScore  float64
                graphDepth  int
                foundBy     map[string]bool // "vector" and/or "graph"
        }
        nodes := make(map[string]*nodeInfo)

        // Step 3: Process vector results and expand via graph
        for _, vr := range vectorResults </span><span class="cov8" title="10">{
                node, err := h.graphStore.GetNode(ctx, vr.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="10">if node == nil </span><span class="cov0" title="0">{
                        continue</span> // Skip stale entries
                }

                // Record vector score
                <span class="cov8" title="10">if _, exists := nodes[vr.ID]; !exists </span><span class="cov7" title="7">{
                        nodes[vr.ID] = &amp;nodeInfo{
                                node:       node,
                                foundBy:    make(map[string]bool),
                                graphDepth: 0, // Direct vector hit
                        }
                }</span>
                <span class="cov8" title="10">nodes[vr.ID].vectorScore = vr.Score
                nodes[vr.ID].foundBy["vector"] = true

                // Step 4: Graph expansion from this vector result
                if opts.GraphDepth &gt; 0 </span><span class="cov8" title="10">{
                        neighbors, err := h.expandFromNode(ctx, vr.ID, opts.GraphDepth)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="10">for neighborID, depthInfo := range neighbors </span><span class="cov7" title="8">{
                                // Skip if it's the same node
                                if neighborID == vr.ID </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov7" title="8">neighborNode, err := h.graphStore.GetNode(ctx, neighborID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov7" title="8">if neighborNode == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Calculate graph score: 1 / (1 + depth)
                                <span class="cov7" title="8">graphScore := 1.0 / float64(1+depthInfo.depth)

                                if existing, exists := nodes[neighborID]; !exists </span><span class="cov7" title="8">{
                                        nodes[neighborID] = &amp;nodeInfo{
                                                node:       neighborNode,
                                                graphScore: graphScore,
                                                graphDepth: depthInfo.depth,
                                                foundBy:    map[string]bool{"graph": true},
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        // Node already exists (maybe from vector or another expansion)
                                        // Update graph score if this path is better
                                        if graphScore &gt; existing.graphScore </span><span class="cov0" title="0">{
                                                existing.graphScore = graphScore
                                                existing.graphDepth = depthInfo.depth
                                        }</span>
                                        <span class="cov0" title="0">existing.foundBy["graph"] = true</span>
                                }
                        }
                }
        }

        // Step 5: Deduplicate, merge scores, and build results
        <span class="cov6" title="6">results := make([]SearchResult, 0, len(nodes))
        for nodeID, info := range nodes </span><span class="cov9" title="15">{
                // Combined score = vector_score + graph_score
                combinedScore := info.vectorScore + info.graphScore

                // Determine source
                source := ""
                if info.foundBy["vector"] &amp;&amp; info.foundBy["graph"] </span><span class="cov4" title="3">{
                        source = "hybrid"
                }</span> else<span class="cov8" title="12"> if info.foundBy["vector"] </span><span class="cov7" title="7">{
                        source = "vector"
                }</span> else<span class="cov6" title="5"> {
                        source = "graph"
                }</span>

                <span class="cov9" title="15">results = append(results, SearchResult{
                        NodeID:     nodeID,
                        Node:       info.node,
                        Score:      combinedScore,
                        Source:     source,
                        GraphDepth: info.graphDepth,
                })</span>
        }

        // Step 6: Sort by combined score descending
        <span class="cov6" title="6">sort.Slice(results, func(i, j int) bool </span><span class="cov8" title="11">{
                return results[i].Score &gt; results[j].Score
        }</span>)

        // Step 7: Return top-K results
        <span class="cov6" title="6">if len(results) &gt; opts.TopK </span><span class="cov1" title="1">{
                results = results[:opts.TopK]
        }</span>

        <span class="cov6" title="6">return results, nil</span>
}

type depthInfo struct {
        depth int
}

// expandFromNode performs BFS graph traversal from a starting node.
func (h *HybridSearcher) expandFromNode(ctx context.Context, startNodeID string, maxDepth int) (map[string]depthInfo, error) <span class="cov8" title="10">{
        result := make(map[string]depthInfo)
        visited := make(map[string]bool)

        type queueItem struct {
                nodeID string
                depth  int
        }
        queue := []queueItem{{startNodeID, 0}}
        visited[startNodeID] = true

        for len(queue) &gt; 0 </span><span class="cov10" title="18">{
                current := queue[0]
                queue = queue[1:]

                if current.depth &gt;= maxDepth </span><span class="cov7" title="7">{
                        continue</span>
                }

                <span class="cov8" title="11">neighbors, err := h.graphStore.GetNeighbors(ctx, current.nodeID, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="11">nextDepth := current.depth + 1
                for _, neighbor := range neighbors </span><span class="cov7" title="8">{
                        // Record depth info (keep shortest path)
                        if existing, exists := result[neighbor.ID]; !exists || nextDepth &lt; existing.depth </span><span class="cov7" title="8">{
                                result[neighbor.ID] = depthInfo{depth: nextDepth}
                        }</span>

                        <span class="cov7" title="8">if !visited[neighbor.ID] </span><span class="cov7" title="8">{
                                visited[neighbor.ID] = true
                                queue = append(queue, queueItem{neighbor.ID, nextDepth})
                        }</span>
                }
        }

        <span class="cov8" title="10">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package search provides search implementations for gognee's knowledge graph.
package search

import (
        "context"

        "github.com/dan-solli/gognee/pkg/store"
)

// SearchType specifies the type of search to perform.
type SearchType string

const (
        // SearchTypeVector performs vector similarity search only.
        SearchTypeVector SearchType = "vector"

        // SearchTypeGraph performs graph traversal search only (requires seed nodes).
        SearchTypeGraph SearchType = "graph"

        // SearchTypeHybrid combines vector similarity and graph traversal.
        SearchTypeHybrid SearchType = "hybrid"
)

// SearchResult represents a single search result with scoring metadata.
type SearchResult struct {
        NodeID string      // Unique identifier of the node
        Node   *store.Node // Full node data (nil if node was deleted)
        Score  float64     // Combined relevance score (higher is better)
        Source string      // Origin: "vector", "graph", or "hybrid"
        // GraphDepth indicates the minimum graph distance from the search origin.
        // 0 for direct vector hits, &gt;0 for nodes discovered via graph expansion.
        GraphDepth int
}

// SearchOptions configures search behavior.
type SearchOptions struct {
        Type       SearchType // Type of search to perform
        TopK       int        // Maximum number of results to return (default: 10)
        GraphDepth int        // Maximum graph traversal depth (default: 1)
        // SeedNodeIDs specifies starting nodes for graph search.
        // Required for SearchTypeGraph; ignored for SearchTypeVector.
        // For SearchTypeHybrid, seeds augment vector results.
        SeedNodeIDs []string
}

// Searcher defines the interface for knowledge graph search.
type Searcher interface {
        // Search performs a search based on the query and options.
        // For vector/hybrid search, query is the text to embed and search.
        // For graph search, query is ignored (uses opts.SeedNodeIDs instead).
        Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error)
}

// ApplyDefaults sets default values for unspecified search options.
func ApplyDefaults(opts *SearchOptions) <span class="cov10" title="16">{
        if opts.TopK &lt;= 0 </span><span class="cov0" title="0">{
                opts.TopK = 10
        }</span>
        <span class="cov10" title="16">if opts.GraphDepth &lt;= 0 </span><span class="cov5" title="4">{
                opts.GraphDepth = 1
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package search

import (
        "context"

        "github.com/dan-solli/gognee/pkg/embeddings"
        "github.com/dan-solli/gognee/pkg/store"
)

// VectorSearcher performs vector similarity search.
type VectorSearcher struct {
        embeddings  embeddings.EmbeddingClient
        vectorStore store.VectorStore
        graphStore  store.GraphStore
}

// NewVectorSearcher creates a new vector searcher.
func NewVectorSearcher(
        embClient embeddings.EmbeddingClient,
        vectorStore store.VectorStore,
        graphStore store.GraphStore,
) *VectorSearcher <span class="cov7" title="4">{
        return &amp;VectorSearcher{
                embeddings:  embClient,
                vectorStore: vectorStore,
                graphStore:  graphStore,
        }
}</span>

// Search performs vector similarity search.
// It embeds the query, searches the vector store, and enriches results with full node data.
func (v *VectorSearcher) Search(ctx context.Context, query string, opts SearchOptions) ([]SearchResult, error) <span class="cov7" title="4">{
        ApplyDefaults(&amp;opts)

        // Embed the query
        embedding, err := v.embeddings.EmbedOne(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Vector search
        <span class="cov7" title="4">vectorResults, err := v.vectorStore.Search(ctx, embedding, opts.TopK)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Enrich with full node data
        <span class="cov7" title="4">results := make([]SearchResult, 0, len(vectorResults))
        for _, vr := range vectorResults </span><span class="cov10" title="7">{
                node, err := v.graphStore.GetNode(ctx, vr.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Skip if node not found (stale vector index)
                <span class="cov10" title="7">if node == nil </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov9" title="6">results = append(results, SearchResult{
                        NodeID:     vr.ID,
                        Node:       node,
                        Score:      vr.Score,
                        Source:     "vector",
                        GraphDepth: 0,
                })</span>
        }

        <span class="cov7" title="4">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package store

import (
        "context"
        "sort"
        "sync"
)

// MemoryVectorStore is an in-memory implementation of VectorStore.
// It uses a map to store vectors and provides thread-safe access via RWMutex.
// Note: This implementation does not persist vectors across restarts.
type MemoryVectorStore struct {
        vectors map[string][]float32
        mu      sync.RWMutex
}

// NewMemoryVectorStore creates a new in-memory vector store.
func NewMemoryVectorStore() *MemoryVectorStore <span class="cov3" title="9">{
        return &amp;MemoryVectorStore{
                vectors: make(map[string][]float32),
        }
}</span>

// Add adds or updates a vector for the given ID.
func (m *MemoryVectorStore) Add(ctx context.Context, id string, embedding []float32) error <span class="cov5" title="127">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Make a copy to avoid external mutations
        embeddingCopy := make([]float32, len(embedding))
        copy(embeddingCopy, embedding)

        m.vectors[id] = embeddingCopy
        return nil
}</span>

// Search finds the most similar vectors to the query.
// Returns up to topK results sorted by similarity score (descending).
func (m *MemoryVectorStore) Search(ctx context.Context, query []float32, topK int) ([]SearchResult, error) <span class="cov5" title="110">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Handle empty store
        if len(m.vectors) == 0 </span><span class="cov1" title="2">{
                return []SearchResult{}, nil
        }</span>

        // Compute similarity for all vectors
        <span class="cov5" title="108">var results []SearchResult
        for id, embedding := range m.vectors </span><span class="cov9" title="10026">{
                score := CosineSimilarity(query, embedding)
                results = append(results, SearchResult{
                        ID:    id,
                        Score: score,
                })
        }</span>

        // Sort by score descending
        <span class="cov5" title="108">sort.Slice(results, func(i, j int) bool </span><span class="cov10" title="16628">{
                return results[i].Score &gt; results[j].Score
        }</span>)

        // Return top-K
        <span class="cov5" title="108">if topK &lt; len(results) </span><span class="cov5" title="102">{
                results = results[:topK]
        }</span>

        <span class="cov5" title="108">return results, nil</span>
}

// Delete removes a vector from the store.
func (m *MemoryVectorStore) Delete(ctx context.Context, id string) error <span class="cov5" title="101">{
        m.mu.Lock()
        defer m.mu.Unlock()

        delete(m.vectors, id)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package store

import (
        "context"
        "database/sql"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/google/uuid"
        _ "modernc.org/sqlite" // SQLite driver
)

// SQLiteGraphStore implements GraphStore using SQLite as the backend.
type SQLiteGraphStore struct {
        db *sql.DB
}

// NewSQLiteGraphStore creates a new SQLite-backed graph store.
// The dbPath can be a file path or ":memory:" for an in-memory database.
// Creates tables and indexes if they don't exist.
func NewSQLiteGraphStore(dbPath string) (*SQLiteGraphStore, error) <span class="cov6" title="31">{
        db, err := sql.Open("sqlite", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov6" title="31">store := &amp;SQLiteGraphStore{db: db}
        if err := store.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov6" title="31">return store, nil</span>
}

// initSchema creates the database schema if it doesn't exist.
// Also performs schema migrations for new columns.
func (s *SQLiteGraphStore) initSchema() error <span class="cov6" title="31">{
        schema := `
        CREATE TABLE IF NOT EXISTS nodes (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL COLLATE NOCASE,
                type TEXT,
                description TEXT,
                embedding BLOB,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                metadata TEXT
        );

        CREATE INDEX IF NOT EXISTS idx_nodes_name ON nodes(name COLLATE NOCASE);

        CREATE TABLE IF NOT EXISTS edges (
                id TEXT PRIMARY KEY,
                source_id TEXT NOT NULL,
                relation TEXT NOT NULL,
                target_id TEXT NOT NULL,
                weight REAL DEFAULT 1.0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (source_id) REFERENCES nodes(id),
                FOREIGN KEY (target_id) REFERENCES nodes(id)
        );

        CREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_id);
        CREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_id);
        `

        _, err := s.db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Run schema migrations for new columns
        <span class="cov6" title="31">return s.migrateSchema()</span>
}

// migrateSchema adds new columns to existing tables if they don't exist.
func (s *SQLiteGraphStore) migrateSchema() error <span class="cov6" title="31">{
        // Check and add last_accessed_at column
        if !s.columnExists("nodes", "last_accessed_at") </span><span class="cov5" title="29">{
                _, err := s.db.Exec("ALTER TABLE nodes ADD COLUMN last_accessed_at DATETIME DEFAULT NULL")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add last_accessed_at column: %w", err)
                }</span>
        }

        // Check and add access_count column
        <span class="cov6" title="31">if !s.columnExists("nodes", "access_count") </span><span class="cov5" title="29">{
                _, err := s.db.Exec("ALTER TABLE nodes ADD COLUMN access_count INTEGER DEFAULT 0")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add access_count column: %w", err)
                }</span>
        }

        <span class="cov6" title="31">return nil</span>
}

// columnExists checks if a column exists in a table.
func (s *SQLiteGraphStore) columnExists(tableName, columnName string) bool <span class="cov7" title="62">{
        query := fmt.Sprintf("PRAGMA table_info(%s)", tableName)
        rows, err := s.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="62">defer rows.Close()

        for rows.Next() </span><span class="cov10" title="469">{
                var cid int
                var name string
                var ctype string
                var notnull int
                var dfltValue sql.NullString
                var pk int

                err := rows.Scan(&amp;cid, &amp;name, &amp;ctype, &amp;notnull, &amp;dfltValue, &amp;pk)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov10" title="469">if name == columnName </span><span class="cov3" title="4">{
                        return true
                }</span>
        }

        <span class="cov6" title="58">return false</span>
}

// AddNode adds or updates a node in the graph.
func (s *SQLiteGraphStore) AddNode(ctx context.Context, node *Node) error <span class="cov6" title="49">{
        // Generate ID if not provided
        if node.ID == "" </span><span class="cov1" title="1">{
                node.ID = uuid.New().String()
        }</span>

        // Set created time if not provided
        <span class="cov6" title="49">if node.CreatedAt.IsZero() </span><span class="cov6" title="39">{
                node.CreatedAt = time.Now()
        }</span>

        // Serialize embedding to bytes
        <span class="cov6" title="49">var embeddingBytes []byte
        if len(node.Embedding) &gt; 0 </span><span class="cov2" title="2">{
                embeddingBytes = make([]byte, len(node.Embedding)*4)
                for i, v := range node.Embedding </span><span class="cov3" title="6">{
                        binary.LittleEndian.PutUint32(embeddingBytes[i*4:], math.Float32bits(v))
                }</span>
        }

        // Serialize metadata to JSON
        <span class="cov6" title="49">var metadataJSON []byte
        var err error
        if node.Metadata != nil </span><span class="cov2" title="2">{
                metadataJSON, err = json.Marshal(node.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal metadata: %w", err)
                }</span>
        }

        <span class="cov6" title="49">query := `
                INSERT OR REPLACE INTO nodes (id, name, type, description, embedding, created_at, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = s.db.ExecContext(ctx, query,
                node.ID,
                node.Name,
                node.Type,
                node.Description,
                embeddingBytes,
                node.CreatedAt,
                metadataJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add node: %w", err)
        }</span>

        <span class="cov6" title="49">return nil</span>
}

// GetNode retrieves a node by its ID.
// Also updates last_accessed_at timestamp to track access for decay.
func (s *SQLiteGraphStore) GetNode(ctx context.Context, id string) (*Node, error) <span class="cov4" title="15">{
        query := `
                SELECT id, name, type, description, embedding, created_at, metadata
                FROM nodes
                WHERE id = ?
        `

        var node Node
        var embeddingBytes []byte
        var metadataJSON []byte

        err := s.db.QueryRowContext(ctx, query, id).Scan(
                &amp;node.ID,
                &amp;node.Name,
                &amp;node.Type,
                &amp;node.Description,
                &amp;embeddingBytes,
                &amp;node.CreatedAt,
                &amp;metadataJSON,
        )

        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                return nil, nil // Not found, no error
        }</span>
        <span class="cov4" title="13">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get node: %w", err)
        }</span>

        // Deserialize embedding
        <span class="cov4" title="13">if len(embeddingBytes) &gt; 0 </span><span class="cov1" title="1">{
                node.Embedding = make([]float32, len(embeddingBytes)/4)
                for i := range node.Embedding </span><span class="cov2" title="3">{
                        node.Embedding[i] = math.Float32frombits(binary.LittleEndian.Uint32(embeddingBytes[i*4:]))
                }</span>
        }

        // Deserialize metadata
        <span class="cov4" title="13">if len(metadataJSON) &gt; 0 </span><span class="cov1" title="1">{
                if err := json.Unmarshal(metadataJSON, &amp;node.Metadata); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                }</span>
        }

        // Update last_accessed_at timestamp
        <span class="cov4" title="13">_, err = s.db.ExecContext(ctx, "UPDATE nodes SET last_accessed_at = ? WHERE id = ?", time.Now(), id)
        if err != nil </span>{<span class="cov0" title="0">
                // Log but don't fail - access tracking is not critical
                // In production, could use a logger here
        }</span>

        <span class="cov4" title="13">return &amp;node, nil</span>
}

// FindNodesByName searches for nodes by name using case-insensitive matching.
func (s *SQLiteGraphStore) FindNodesByName(ctx context.Context, name string) ([]*Node, error) <span class="cov3" title="4">{
        query := `
                SELECT id, name, type, description, embedding, created_at, metadata
                FROM nodes
                WHERE LOWER(name) = LOWER(?)
                ORDER BY created_at, id
        `

        rows, err := s.db.QueryContext(ctx, query, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find nodes by name: %w", err)
        }</span>
        <span class="cov3" title="4">defer rows.Close()

        var nodes []*Node
        for rows.Next() </span><span class="cov3" title="6">{
                var node Node
                var embeddingBytes []byte
                var metadataJSON []byte

                err := rows.Scan(
                        &amp;node.ID,
                        &amp;node.Name,
                        &amp;node.Type,
                        &amp;node.Description,
                        &amp;embeddingBytes,
                        &amp;node.CreatedAt,
                        &amp;metadataJSON,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan node: %w", err)
                }</span>

                // Deserialize embedding
                <span class="cov3" title="6">if len(embeddingBytes) &gt; 0 </span><span class="cov0" title="0">{
                        node.Embedding = make([]float32, len(embeddingBytes)/4)
                        for i := range node.Embedding </span><span class="cov0" title="0">{
                                node.Embedding[i] = math.Float32frombits(binary.LittleEndian.Uint32(embeddingBytes[i*4:]))
                        }</span>
                }

                // Deserialize metadata
                <span class="cov3" title="6">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(metadataJSON, &amp;node.Metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                        }</span>
                }

                <span class="cov3" title="6">nodes = append(nodes, &amp;node)</span>
        }

        <span class="cov3" title="4">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating nodes: %w", err)
        }</span>

        <span class="cov3" title="4">return nodes, nil</span>
}

// FindNodeByName is a convenience method that returns a single node if exactly one matches.
func (s *SQLiteGraphStore) FindNodeByName(ctx context.Context, name string) (*Node, error) <span class="cov2" title="3">{
        nodes, err := s.FindNodesByName(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">if len(nodes) == 0 </span><span class="cov1" title="1">{
                return nil, ErrNodeNotFound
        }</span>

        <span class="cov2" title="2">if len(nodes) &gt; 1 </span><span class="cov1" title="1">{
                return nil, ErrAmbiguousNode
        }</span>

        <span class="cov1" title="1">return nodes[0], nil</span>
}

// AddEdge adds or updates an edge in the graph.
func (s *SQLiteGraphStore) AddEdge(ctx context.Context, edge *Edge) error <span class="cov5" title="17">{
        // Generate ID if not provided
        if edge.ID == "" </span><span class="cov0" title="0">{
                edge.ID = uuid.New().String()
        }</span>

        // Set created time if not provided
        <span class="cov5" title="17">if edge.CreatedAt.IsZero() </span><span class="cov4" title="12">{
                edge.CreatedAt = time.Now()
        }</span>

        // Default weight to 1.0 if not provided
        <span class="cov5" title="17">if edge.Weight == 0 </span><span class="cov4" title="12">{
                edge.Weight = 1.0
        }</span>

        <span class="cov5" title="17">query := `
                INSERT OR REPLACE INTO edges (id, source_id, relation, target_id, weight, created_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := s.db.ExecContext(ctx, query,
                edge.ID,
                edge.SourceID,
                edge.Relation,
                edge.TargetID,
                edge.Weight,
                edge.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add edge: %w", err)
        }</span>

        <span class="cov5" title="17">return nil</span>
}

// GetEdges retrieves all edges incident to a node (both incoming and outgoing).
func (s *SQLiteGraphStore) GetEdges(ctx context.Context, nodeID string) ([]*Edge, error) <span class="cov4" title="11">{
        query := `
                SELECT id, source_id, relation, target_id, weight, created_at
                FROM edges
                WHERE source_id = ? OR target_id = ?
                ORDER BY created_at
        `

        rows, err := s.db.QueryContext(ctx, query, nodeID, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get edges: %w", err)
        }</span>
        <span class="cov4" title="11">defer rows.Close()

        var edges []*Edge
        for rows.Next() </span><span class="cov4" title="15">{
                var edge Edge
                err := rows.Scan(
                        &amp;edge.ID,
                        &amp;edge.SourceID,
                        &amp;edge.Relation,
                        &amp;edge.TargetID,
                        &amp;edge.Weight,
                        &amp;edge.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan edge: %w", err)
                }</span>
                <span class="cov4" title="15">edges = append(edges, &amp;edge)</span>
        }

        <span class="cov4" title="11">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating edges: %w", err)
        }</span>

        <span class="cov4" title="11">return edges, nil</span>
}

// GetNeighbors retrieves all nodes adjacent to a given node, up to the specified depth.
func (s *SQLiteGraphStore) GetNeighbors(ctx context.Context, nodeID string, depth int) ([]*Node, error) <span class="cov2" title="3">{
        if depth &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("depth must be at least 1")
        }</span>

        // Track visited nodes to avoid duplicates
        <span class="cov2" title="3">visited := make(map[string]bool)
        visited[nodeID] = true

        // Current frontier of nodes to explore
        frontier := []string{nodeID}

        // For each depth level
        for d := 0; d &lt; depth; d++ </span><span class="cov3" title="5">{
                var nextFrontier []string

                // For each node in current frontier
                for _, currentID := range frontier </span><span class="cov3" title="6">{
                        // Get all incident edges
                        edges, err := s.GetEdges(ctx, currentID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Find neighbor node IDs
                        <span class="cov3" title="6">for _, edge := range edges </span><span class="cov4" title="11">{
                                var neighborID string
                                if edge.SourceID == currentID </span><span class="cov3" title="6">{
                                        neighborID = edge.TargetID
                                }</span> else<span class="cov3" title="5"> {
                                        neighborID = edge.SourceID
                                }</span>

                                // Add to next frontier if not visited
                                <span class="cov4" title="11">if !visited[neighborID] </span><span class="cov3" title="6">{
                                        visited[neighborID] = true
                                        nextFrontier = append(nextFrontier, neighborID)
                                }</span>
                        }
                }

                <span class="cov3" title="5">frontier = nextFrontier
                if len(frontier) == 0 </span><span class="cov1" title="1">{
                        break</span> // No more neighbors to explore
                }
        }

        // Remove the starting node from visited set
        <span class="cov2" title="3">delete(visited, nodeID)

        // Fetch all neighbor nodes
        var neighbors []*Node
        for neighborID := range visited </span><span class="cov3" title="6">{
                node, err := s.GetNode(ctx, neighborID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="6">if node != nil </span><span class="cov3" title="6">{
                        neighbors = append(neighbors, node)
                }</span>
        }

        <span class="cov2" title="3">return neighbors, nil</span>
}

// NodeCount returns the total number of nodes in the graph.
func (s *SQLiteGraphStore) NodeCount(ctx context.Context) (int64, error) <span class="cov3" title="7">{
        var count int64
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM nodes").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count nodes: %w", err)
        }</span>
        <span class="cov3" title="7">return count, nil</span>
}

// EdgeCount returns the total number of edges in the graph.
func (s *SQLiteGraphStore) EdgeCount(ctx context.Context) (int64, error) <span class="cov3" title="7">{
        var count int64
        err := s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM edges").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count edges: %w", err)
        }</span>
        <span class="cov3" title="7">return count, nil</span>
}

// UpdateAccessTime updates the last_accessed_at timestamp for a batch of nodes.
// This is used for access reinforcement in memory decay.
func (s *SQLiteGraphStore) UpdateAccessTime(ctx context.Context, nodeIDs []string) error <span class="cov2" title="3">{
        if len(nodeIDs) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Build IN clause with placeholders
        <span class="cov2" title="2">placeholders := make([]string, len(nodeIDs))
        args := make([]interface{}, len(nodeIDs)+1)
        args[0] = time.Now()

        for i, nodeID := range nodeIDs </span><span class="cov2" title="3">{
                placeholders[i] = "?"
                args[i+1] = nodeID
        }</span>

        <span class="cov2" title="2">query := fmt.Sprintf("UPDATE nodes SET last_accessed_at = ? WHERE id IN (%s)",
                strings.Join(placeholders, ","))

        _, err := s.db.ExecContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update access time: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// GetAllNodes returns all nodes in the graph (for pruning operations).
func (s *SQLiteGraphStore) GetAllNodes(ctx context.Context) ([]*Node, error) <span class="cov1" title="1">{
        query := `
                SELECT id, name, type, description, embedding, created_at, metadata, last_accessed_at
                FROM nodes
                ORDER BY created_at, id
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query all nodes: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var nodes []*Node
        for rows.Next() </span><span class="cov2" title="2">{
                var node Node
                var embeddingBytes []byte
                var metadataJSON []byte
                var lastAccessed sql.NullTime

                err := rows.Scan(
                        &amp;node.ID,
                        &amp;node.Name,
                        &amp;node.Type,
                        &amp;node.Description,
                        &amp;embeddingBytes,
                        &amp;node.CreatedAt,
                        &amp;metadataJSON,
                        &amp;lastAccessed,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan node: %w", err)
                }</span>

                // Deserialize embedding
                <span class="cov2" title="2">if len(embeddingBytes) &gt; 0 </span><span class="cov1" title="1">{
                        node.Embedding = make([]float32, len(embeddingBytes)/4)
                        for i := range node.Embedding </span><span class="cov2" title="3">{
                                node.Embedding[i] = math.Float32frombits(binary.LittleEndian.Uint32(embeddingBytes[i*4:]))
                        }</span>
                }

                // Deserialize metadata
                <span class="cov2" title="2">if len(metadataJSON) &gt; 0 </span><span class="cov1" title="1">{
                        if err := json.Unmarshal(metadataJSON, &amp;node.Metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                        }</span>
                }

                // Hydrate last_accessed_at if it's not NULL
                <span class="cov2" title="2">if lastAccessed.Valid </span><span class="cov1" title="1">{
                        node.LastAccessedAt = &amp;lastAccessed.Time
                }</span>

                <span class="cov2" title="2">nodes = append(nodes, &amp;node)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating nodes: %w", err)
        }</span>

        <span class="cov1" title="1">return nodes, nil</span>
}

// DeleteNode removes a node from the graph.
func (s *SQLiteGraphStore) DeleteNode(ctx context.Context, nodeID string) error <span class="cov1" title="1">{
        _, err := s.db.ExecContext(ctx, "DELETE FROM nodes WHERE id = ?", nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete node: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// DeleteEdge removes an edge from the graph.
func (s *SQLiteGraphStore) DeleteEdge(ctx context.Context, edgeID string) error <span class="cov1" title="1">{
        _, err := s.db.ExecContext(ctx, "DELETE FROM edges WHERE id = ?", edgeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete edge: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Close releases database resources.
func (s *SQLiteGraphStore) Close() error <span class="cov6" title="31">{
        return s.db.Close()
}</span>

// DB returns the underlying database connection.
// This connection is shared with other stores (e.g., SQLiteVectorStore)
// and must not be closed by consumers.
func (s *SQLiteGraphStore) DB() *sql.DB <span class="cov1" title="1">{
        return s.db
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package store

import (
        "context"
        "database/sql"
        "encoding/binary"
        "fmt"
        "math"
        "sort"
)

// SQLiteVectorStore implements VectorStore using SQLite as the persistence layer.
// It stores embeddings in the nodes.embedding BLOB column and provides
// vector similarity search using cosine similarity computed in Go.
//
// Implementation notes:
// - Embeddings are stored directly in the nodes table's embedding column
// - Search performs a linear scan (SELECT all non-NULL embeddings, compute similarity in Go)
// - No in-memory caching - SQLite is the source of truth
// - Dimension mismatches are handled by skipping incompatible vectors during search
// - The database connection is shared with SQLiteGraphStore and must not be closed by this store
type SQLiteVectorStore struct {
        db *sql.DB
}

// NewSQLiteVectorStore creates a new SQLite-backed vector store.
// The database connection is shared and owned by the caller (typically SQLiteGraphStore).
// The SQLiteVectorStore must not close this connection.
func NewSQLiteVectorStore(db *sql.DB) *SQLiteVectorStore <span class="cov2" title="15">{
        return &amp;SQLiteVectorStore{db: db}
}</span>

// Add adds or updates an embedding for the given node ID.
// The node must already exist in the nodes table.
// Returns an error if the node doesn't exist or if the database operation fails.
func (s *SQLiteVectorStore) Add(ctx context.Context, id string, embedding []float32) error <span class="cov6" title="1313">{
        if len(embedding) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("embedding cannot be empty")
        }</span>

        // Serialize embedding to binary format (little-endian float32 array)
        <span class="cov6" title="1312">blob := serializeEmbedding(embedding)

        // Update the embedding column for the specified node
        result, err := s.db.ExecContext(ctx, `UPDATE nodes SET embedding = ? WHERE id = ?`, blob, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update embedding: %w", err)
        }</span>

        // Check if the node exists
        <span class="cov6" title="1312">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check rows affected: %w", err)
        }</span>
        <span class="cov6" title="1312">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("node %s not found", id)
        }</span>

        <span class="cov6" title="1311">return nil</span>
}

// Search finds the most similar vectors to the query using cosine similarity.
// Performs a direct-query linear scan: SELECT all non-NULL embeddings from the database,
// compute cosine similarity in Go, and return the top-K results sorted by score descending.
//
// Behavior:
// - Nodes without embeddings (NULL) are skipped
// - Embeddings with dimensions different from the query are skipped (CosineSimilarity returns 0)
// - Results are sorted by similarity score in descending order
// - Returns up to topK results (may be fewer if the store has fewer vectors)
func (s *SQLiteVectorStore) Search(ctx context.Context, query []float32, topK int) ([]SearchResult, error) <span class="cov6" title="1258">{
        if len(query) == 0 </span><span class="cov1" title="1">{
                return []SearchResult{}, nil
        }</span>

        // Query all nodes with non-NULL embeddings
        <span class="cov6" title="1257">rows, err := s.db.QueryContext(ctx, `SELECT id, embedding FROM nodes WHERE embedding IS NOT NULL`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query embeddings: %w", err)
        }</span>
        <span class="cov6" title="1257">defer rows.Close()

        var results []SearchResult
        for rows.Next() </span><span class="cov8" title="62510">{
                var id string
                var embeddingBlob []byte

                if err := rows.Scan(&amp;id, &amp;embeddingBlob); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // Deserialize embedding
                <span class="cov8" title="62510">embedding := deserializeEmbedding(embeddingBlob)
                if embedding == nil </span><span class="cov1" title="1">{
                        // Skip malformed embeddings
                        continue</span>
                }

                // Compute similarity (CosineSimilarity returns 0 for dimension mismatches)
                <span class="cov8" title="62509">score := CosineSimilarity(query, embedding)
                
                // Skip vectors with dimension mismatch (score will be 0)
                // Only include if dimensions match (non-zero similarity possible)
                if len(embedding) == len(query) </span><span class="cov8" title="62508">{
                        results = append(results, SearchResult{
                                ID:    id,
                                Score: score,
                        })
                }</span>
        }

        <span class="cov6" title="1257">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        // Sort by score descending
        <span class="cov6" title="1257">sort.Slice(results, func(i, j int) bool </span><span class="cov10" title="341111">{
                return results[i].Score &gt; results[j].Score
        }</span>)

        // Return top-K
        <span class="cov6" title="1257">if topK &lt; len(results) </span><span class="cov6" title="1251">{
                results = results[:topK]
        }</span>

        <span class="cov6" title="1257">return results, nil</span>
}

// Delete removes the embedding for the given node ID.
// The node itself is not deleted, only the embedding column is set to NULL.
// This allows the node to remain in the graph while removing it from vector search.
func (s *SQLiteVectorStore) Delete(ctx context.Context, id string) error <span class="cov1" title="1">{
        _, err := s.db.ExecContext(ctx, `UPDATE nodes SET embedding = NULL WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete embedding: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Close is a no-op for SQLiteVectorStore because it shares the database connection
// with SQLiteGraphStore. The connection lifecycle is managed by the owner (GraphStore).
func (s *SQLiteVectorStore) Close() error <span class="cov1" title="1">{
        // No-op: connection is owned by GraphStore
        return nil
}</span>

// serializeEmbedding converts a float32 slice to a binary BLOB for storage.
// Uses little-endian encoding for consistency across platforms.
func serializeEmbedding(embedding []float32) []byte <span class="cov6" title="1312">{
        blob := make([]byte, len(embedding)*4)
        for i, val := range embedding </span><span class="cov6" title="3934">{
                bits := math.Float32bits(val)
                binary.LittleEndian.PutUint32(blob[i*4:(i+1)*4], bits)
        }</span>
        <span class="cov6" title="1312">return blob</span>
}

// deserializeEmbedding converts a binary BLOB back to a float32 slice.
// Returns nil if the data is malformed (not a multiple of 4 bytes).
func deserializeEmbedding(data []byte) []float32 <span class="cov8" title="62510">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="62510">if len(data)%4 != 0 </span><span class="cov1" title="1">{
                // Malformed data
                return nil
        }</span>

        <span class="cov8" title="62509">embedding := make([]float32, len(data)/4)
        for i := 0; i &lt; len(embedding); i++ </span><span class="cov9" title="187525">{
                bits := binary.LittleEndian.Uint32(data[i*4 : (i+1)*4])
                embedding[i] = math.Float32frombits(bits)
        }</span>
        <span class="cov8" title="62509">return embedding</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package store

import (
        "context"
        "math"
)

// SearchResult represents a vector search result with similarity score.
type SearchResult struct {
        ID    string  // Node ID
        Score float64 // Cosine similarity score (0-1, higher is more similar)
}

// VectorStore defines the interface for vector storage and similarity search.
type VectorStore interface {
        // Add adds or updates a vector for the given ID.
        Add(ctx context.Context, id string, embedding []float32) error

        // Search finds the most similar vectors to the query.
        // Returns up to topK results sorted by similarity score (descending).
        Search(ctx context.Context, query []float32, topK int) ([]SearchResult, error)

        // Delete removes a vector from the store.
        Delete(ctx context.Context, id string) error
}

// CosineSimilarity computes the cosine similarity between two vectors.
// Returns a value between -1 and 1, where 1 means identical direction,
// 0 means orthogonal, and -1 means opposite direction.
// For normalized vectors (embeddings), the result is typically between 0 and 1.
func CosineSimilarity(a, b []float32) float64 <span class="cov9" title="72543">{
        if len(a) != len(b) </span><span class="cov1" title="2">{
                return 0.0
        }</span>

        <span class="cov9" title="72541">if len(a) == 0 </span><span class="cov1" title="1">{
                return 0.0
        }</span>

        <span class="cov9" title="72540">var dotProduct, normA, normB float64

        for i := 0; i &lt; len(a); i++ </span><span class="cov10" title="220684">{
                dotProduct += float64(a[i]) * float64(b[i])
                normA += float64(a[i]) * float64(a[i])
                normB += float64(b[i]) * float64(b[i])
        }</span>

        <span class="cov9" title="72540">if normA == 0 || normB == 0 </span><span class="cov4" title="101">{
                return 0.0
        }</span>

        <span class="cov9" title="72439">return dotProduct / (math.Sqrt(normA) * math.Sqrt(normB))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
